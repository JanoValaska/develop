# Performance Monitoring SDK API

## Introduction

What follows is a quick story of how Performance Monitoring was added Sentry.

The focus is on the SDK API, and what was happening in the industry around the same time, notably OpenTelemetry.

Back in 2019, Sentry started experimenting with [adding tracing to SDKs](https://github.com/getsentry/sentry-python/pull/342).
That work was contemporary to the [merger of OpenCensus and OpenTracing to form OpenTelemetry](https://medium.com/opentracing/a-roadmap-to-convergence-b074e5815289).

While we had ideas of our own, our API and implementations borrowed inspiration from pre-1.0 versions of OpenTelemetry, when OpenTelemetry was still in its infancy.
For example, our [list of span statuses](https://github.com/getsentry/relay/blob/55127c75d4eeebf787848a05a12150ee5c59acd9/relay-common/src/constants.rs#L179-L181) openly match those that could be found in the OpenTelemetry spec around the end of 2019.

[Sentry's Performance Monitoring](https://blog.sentry.io/2020/07/14/see-slow-faster-with-performance-monitoring) solution became *Generally Available* in July, 2020.
[OpenTelemetry's Tracing Specification version 1.0](https://medium.com/opentelemetry/opentelemetry-specification-v1-0-0-tracing-edition-72dd08936978) was released in February, 2021.

Here's a picture to help understand the timeline:

<<<<<<<<<<<https://time.graphics/editor>>>>>>>>>


## Initial Implementation

Our initial implementation reused the mechanisms we had in place for error reporting:
- The [`Event` type](https://develop.sentry.dev/sdk/event-payloads/) was extended with new fields. That meant that instead of designing and implementing a whole new ingestion pipeline, we could save time and quickly start sending "events" to Sentry, this time, instead of errors, a new "transaction" event type.
- Since we were just sending a new type of event, the SDK transport layer was also reused.
- And since we were sharing the ingestion pipeline, that meant we were sharing storage and the many parts of the processing that happens to all events.

Our implementation evolved such that there was a clear emphasis on the distiction between Transactions and Spans.
Part of that was a side

Transactions resonated well with customers. The concept helped people understand ...

But that model has both extra complexities for instrumentation and limited our ingestion model requiring grouping all spans in memory before sending.

In SDKs, transactions are quite different from other spans in that they are embedded in a Sentry event container and follow a different protocol format than spans. Spans themselves can only be contained by a transaction.


## Notable Changes

Although not strictly related to transactions, the [Envelope](https://develop.sentry.dev/sdk/envelopes/) format was introduced, adding more metadata to request payloads and allowing sending different data types to the same endpoint.

Over time, we had to make adjustments in the backend, for example splitting the storage of errors and transactions.





## Next Steps

- More and more customers are aware of OpenTelemetry and are using it in their backends
- We want to re-align our model with OpenTelemetry
- We want to eventually support metrics collection on all observable spans
- De-emphasize transactions on the user-facing API to make it easier to instrument code without having to undestand how the network protocol works
- Simplify manual instrumentation steps
- Users will mostly think of only spans
- Clear migration path for users, minimizing breakage
- Better context management
- Evolve network protocol
- Evolve product to better visualize traces, transactions and spans that happen outside of transactions

Next Steps

- Introduce helper to start spans/transactions + manage scope
- Introduce span processor
- Evaluate

- Work on ingestion; can we ingest spans that are not transactions?
- Work on product to shift focus from transactions into traces and spans outside transactions
